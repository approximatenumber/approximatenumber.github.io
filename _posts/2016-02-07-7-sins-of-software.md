---
layout: post
title: Семь смертных грехов проекта
tags: bugaenko translation dev
comments: True
excerpt_separator: <!--more-->
---

<small>*Перевод статьи Е. Бугаенко [«Seven Deadly Sins of a Software Project»](http://www.yegor256.com/2015/06/08/deadly-sins-software-project.html).*</small>

Поддерживаемость (maintainability) – самое ценное свойство современной разработки ПО. Поддерживаемость может измеряться в основном как рабочее время, требуемое для нового разработчика, чтобы изучить ПО перед тем, как он или она сможет делать в нем серьезные изменения. Чем дольше время, тем ниже степень. В некоторых проектах это временнОе требование приближается к бесконечности, это означает, что эти проекты буквально невозможно поддерживать. Я считаю, что существует 7 основных и фатальных грехов, которые лишают наше ПО возможности поддержки. И вот они.

<!--more-->

## Анти-паттерны 
<img src="/images/software-project-sins-1.gif" class="sticker">

К сожалению, языки программирования, которые мы используем, слишком гибкие. Они очень много всего позволяют, а запрещают очень мало. Например, Java непротив того, чтобы вы поместили целое приложение в один единственный «класс» с несколькими тысячами методов. С технической точки зрения, приложение скомпилируется и запустится. Но это известный анти-паттерн «божественный объект».

Таким образом, анти-паттерн это технически принимаемый способ проектирования чего-либо, который в общем считается неправильным. В каждом языке существует много анти-паттернов. Их наличие в вашем продукте похоже на опухоль в живом организме. Как только она начинает расти, ее очень трудно остановить. Со временем, весь организм погибает. Со времени, всё ваше ПО становится неподдерживаемым и должно быть переписано.

Как только вы позволите нескольким анти-паттернам присутствовать в проекте, вы будете со временем получать их всё больше и больше, и "опухоль" лишь будет расти.

Это особенно касается языков ООП (Java, C++, Ruby и Python), потому что они так много наследуют от процедурных языков (C, Fortran и COBOL). И потому, что ООП-разработчики предпочитают думать в процедурным и императивным способом. К сожалению.

Кстати, в дополнение к существующему списку известных анти-паттернов, я также рассматриваю вот такие вещи, скорее как плохой подход к программированию.

Моё практическое предложение в таком случае состоит в том, что необходимо читать и изучать. Возможно, эти книги вам помогут. Всегда старайтесь скептически относиться к качеству вашего ПО, и не расслабляйтесь, когда оно "просто работает". Как и с раком: чем раньше вы диагностируете его, тем выше шанс остаться живым.


## Непрослеживаемые изменения
<img src="/images/software-project-sins-2.gif" class="sticker">

Когда я смотрю на историю коммитов, у меня должна быть возможность понять для каждого конкретного изменения, что было изменено, кто это сделал и почему. Более того, время, необходимое для получения трех этих ответов, должно измеряться в секундах. В большинстве проектов это не так. Вот несколько практических рекомендаций:
    
**Всегда используйте тикеты.** Без разницы, насколько мал проект или его команда, даже если это вы сами, создавайте тикеты ("issues" в GitHub) для каждой проблемы, которую вы решаете. Кратко опишите проблему в тикете и напишите там свое мнение. Пишите всё, что может иметь смысл в будущем, когда кто-то еще попытается понять, о чем эти "странные коммиты".

**Ссылайтесь на тикеты в коммитах.** Не стоит и говорить, каждый коммит должен иметь своё сообщение. Коммиты без сообщений -- очень плохая практика; я даже не буду это обсуждать. Но просто лишь сообщения недостаточно. Каждое сообщение должно начинаться с номера тикета, над которым вы работаете. GitHub (я уверен, вы им пользуетесь) будет автоматически связывать коммиты и тикеты, улучшая "прослеживаемость" изменений.

**Ничего не удаляйте.** Git позволяет выполнять "принудительный" push, который перезаписывает весь branch, который до этого был на сервере. Это лишь один пример того, как вы можете удалить историю разработки. Я много раз видел людей, которые удаляли свои комментарии в обсуждениях GitHub, чтобы их тикеты выглядели более "чистыми". Это неправильно. Никогда ничего не удаляйте; позволяйте вашей истории оставаться с вами, без разницы, насколько плохо (или беспорядочно) она сейчас для вас выглядит.

## Специальные релизы
<img src="/images/software-project-sins-3.gif" class="sticker">

Каждая часть ПО должна быть запакована, прежде чем она будет предоставлена конечному пользователю. Если это Java-библиотека, она должна быть запакована как `.jar` файл и опубликована в каком-либо репозитории; если это веб-приложение, его необходимо "развернуть" на какой-либо платформе, и т.д. Без разницы, насколько мал или огромен продукт, необходимо, чтобы существовала стандартная процедура, которая занимается тестированием, "упаковкой" и развертыванием. 

Идеальное решение — автоматизировать эту процедуру, чтобы можно было выполнить ее из командной строки с помощью одной команды:

{%highlight bash%}
$ ./release.sh
...
Выполнено (за 98,7 с)
{%endhighlight%}

Большинство проектов далеки от этого. Их процесс релиза всегда включает в себя немного магии, где ответственный за это (также известный как DevOp) должен кликать какие-то кнопки тут и там, входить куда-то, проверять какие-то значения, и т.д. И такой процесс специального релиза это всё ещё обычный недостаток всей инженерной индустрии ПО.

Я могу лишь дать один практический совет: автоматизируйте это. Я использую rultor.com для этого, но вы можете использовать любые инструменты, которые вам нравятся. Важно, что вся эта процедура полностью автоматизирована и может быть запущена из командной строки. 

## Добровольный статистический анализ
<img src="/images/software-project-sins-4.gif" class="sticker">

Использование статистического анализа позволяет нашему коду выглядеть лучше. Делая это, мы неизбежно позволяем ему и работать лучше. Но это происходит только тогда, когда вся команда вынуждена (!) следовать правилам, созданным статистическим аналитиком (аналитиками). Я написал об этом в статье "Строгий контроль качества Java-кода". Я использую qulice.com в Java-проектах и rubocop в Ruby, но почти для каждого языка существует множество похожих инструментов.

Вы можете использовать любой из них, но обязательно это делайте. В большинстве проектов, где используется статистический анализ, разработчики просто делают хорошо выглядящие отчеты и продолжают писать код так, как делали это раньше. Такой "добровольный" подход не делает никаких одолжений проекту. Более того, он создает иллюзию качества.

Я говорю о том, что статистический анализ должен быть обязательным шагом в системе деплоймента. Сборка проекта не должна пройти, если какое-либо из правил статистического анализа нарушено.


## Неизвестная степень покрытия тестами
<img src="/images/software-project-sins-5.gif" class="sticker">

Скажем просто, что покрытие тестами это состояние ПО, прошедшего юнит- и интеграционное тестирование. Чем больше степень покрытия, тем больший "объем" кода был выполнен во время прохождения тестов. Очевидно, что большая степень покрытия это хорошо.

Однако, многие разработчики проектов просто не знают этой степени покрытия. Они просто не учитывают эту метрику. Они используют какие-то тесты, но никто не знает, насколько глубоко они проникают в проект, и какие его части не протестированы вообще. Такая ситуация намного хуже той, когда у проекта малая степень покрытия тестами, которая измерена и доступна каждому.


Высокая степень покрытия - не гарантия качества, это очевидно. Но неизвестная степень покрытия это явный знак того, что существуют проблемы с поддержкой кода. Когда новый разработчик попадает в проект, он должен иметь возможность изменять что-либо и понимать, на что они влияют. В идеале, степень покрытия тестами необходимо проверять таким же, как и статический анализ, способом, и сборка должна прерваться в случае обнаружения заранее определенного порога (обычно около 80%).


## Непрерывная разработка
<img src="/images/software-project-sins-6.gif" class="sticker">

Под словом "непрерывная" я имею в виду разработка без определенных стадий и релизов. Без разницы, какой именно софт вы пишите, вы должны часто выпускать релизы и контролировать их версии. Проект без понятной истории релизов - это какой-то неподдерживаемый бардак.

Это больше потому, что возможность поддержки - это моя возможность понимать вас, читая ваш код.

Когда я смотрю в исходный код, его коммиты и историю релизов, я должен иметь возможность понять, какие намерения были у его автора, что проект делал год назад, куда он движется теперь, каков его путь и проч. Вся эта информация должна присутствовать в исходном коде и, что наиболее важно, в истории Git.

Теги Git и заметки о релизах в GutHub - это два мощных инструмента, которые обеспечивают меня этой информацией. Используйте их по максимуму. Также, не забывайте, что каждая бинарная версия продукта должна быть доступна для мгновенной загрузки. У меня должна быть возможность скачать версию 0.1.3 и проверить ее прямо сейчас, даже если текущая версия проекта 3.4.


## Недокументированные интерфейсы взаимодействия
<img src="/images/software-project-sins-7.gif" class="sticker">

Каждая часть ПО имеет свои интерфейсы, через которые его принято использовать. Если это гем Ruby, то существуют классы и методы, которые я собираюсь использовать в качестве конечного пользователя этого гема. Если это веб-приложение, то существуют веб-страницы, которыми  конечный пользователь будет управлять, чтобы использовать приложение. У каждого проекта есть интерфейсы, и они должны быть внимательно описаны. 

Как и всё, что сказано выше, это касается возможности поддержки. Я, новый программист в проекте, буду врубаться в проект через его интерфейсы взаимодействия. Я должен понимать, что он делает, и пытаться использовать его сам.

Сейчас я говорю о документации для пользователей, а не для разработчиков. В общем, я против документации внутри ПО. В данном случае я полностью согласен с "Манифестом Agile", -- рабочее ПО важней, чем исчерпывающая документация. Но это не относится к "внешней" документации, которую следует читать пользователям, а не разработчикам.

Поэтому процесс взаимодействия конечного пользователя с ПО должен быть понятно задокументирован.

Если ваше ПО это библиотека, тогда ее конечные пользователи - это разработчики ПО, которые собираются ею пользоваться; не вносить в нее свой вклад, а просто использовать ее как "черный ящик".

------

Это критерии, используемые для оценки open-source проектов, принимающих участие в нашем соревновании за награду.